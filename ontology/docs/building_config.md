# Model Instance Configuration

In addition to a language and primitives for configuring an abstract building
model, the Digital Buildings project provides a YAML configuration syntax for
mapping concrete assets to the abstract model in a lightweight way. The intent
of providing this syntax is to make "manual" onboarding faster and easier
(because the resulting data file is machine readable and can be machine
validated) as well as provide a clean interface format for machine-assisted
onboarding to use.

NB: Some of the instructions here details that are specific to Google's
implementation of this stack on its own campuses (such as references to CloudIoT
registration). These should be relatively obvious to a critical reader, but if
they are confusing feel free to post an issue in the project.

*   For an explanation of types in the Digital Buildings abstract model see
    [model](model.md)
*   For a conceptual explanation of the ontology see [ontology](ontology.md)

- [Model Instance Configuration](#model-instance-configuration)
  * [Key Concepts](#key-concepts)
  * [Typical Data Elements](#typical-data-elements)
  * [Configuration Detail](#configuration-detail)
    + [Contents](#contents)
    + [Config Format](#config-format)
    + [Spaces](#spaces)
    + [Devices](#devices)
      - [Reporting Physical Devices](#reporting-physical-devices)
        * [Defining Translations](#defining-translations)
          + [Translation Shortcuts](#translation-shortcuts)
          + [UDMI Short form](#udmi-short-form)
        * [Metadata](#metadata)
      - [Virtual Devices](#virtual-devices)
      - [Device Relationships](#device-relationships)
    + [Zones and Control Groups](#zones-and-control-groups)
    + [Relationships](#relationships)
  * [Validation](#validation)
  * [Notes](#notes)

## Key Concepts

Creation of a concrete model is primarily concerned with defining entities,
their relationships to each other, and their relationships to real physical
things in the world.

Conceptually, we divide entities into three categories:

*   **Logical Entity**: An entity that maps 1:1 with a canonical concept in the
    model. For example, you might have an idealized concept of an Air Handler,
    with a corresponding entity type, that you may use for analysis. A logical
    air handler would use this type or a child of it.
*   **Reporting Entity**: A reporting entity is one that generates telemetry
    data. Reporting entities are important to differentiate because they may
    have translations to convert their native data payload to a standard form.
*   **Virtual Entity** A virtual entity does NOT directly generate telemetry
    data, but may still have a timeseries that is generated by linking data from
    other sources.

The following statements apply when considering entity categories:

*   Either a Reporting Entity or a Virtual Entity may be a Logical Entity.
*   Virtual Entities are typically also Logical Entities.
*   By convention, anything that receives telemetry is a Reporting Entity, even
    if it has data linked from other entities. In practice, however, we do not
    recommend mixing the two concepts (i.e. by linking additional data from
    other devices into a reporting device).

To completely map real data to the model we also need a few more concepts:

*   **Translation**: A key-value mapping between fields in a reporting device's
    payload and the standard fields in the device's assigned entity type.
*   **Link**: A mapping between a standard field in one device and another
    standard field in another device. Links map data from reporting devices to
    virtual devices.
*   **Connection**: Describes a relationship between two entities. See
    [Connections](ontology_config.md#connections)

These should all be defined in a complete configuration.

## Typical Data Elements

While there is basically infinite diversity in what can be defined for a
building, some elements are more or less expected in every model:

*   All the logical spaces in the building with their unique names (Building,
    Rooms, Floors).
*   Each logical piece of equipment (hereafter "device") and its associated
    Digital Buildings Type.
*   Each reporting device registered in Cloud IoT (or your endpoint of choice,
    if not working on a Google building).
*   Link mappings between the points of reporting devices and logical devices,
    if the two are not the same.
*   Translation mappings between device-native point names and the standard
    point names for each reporting device
*   Zones or Switch Groups, as applicable.
*   `FEEDS` relationships between chained equipment in HVAC or power systems, as
    well as between terminal units and Zones.
*   `CONTROLS` relationships between switch groups and fixtures, and between
    switches and switch groups.
*   `CONTAINS` relationships between Zones or Switch Groups and rooms.
*   `CONTAINS` relationships between all entities and floors (or more specific
    space, if known).
*   `CONTAINS` relationships between Buildings and floors, and floors and rooms.

## Configuration Detail

### Contents

Each configuration file should contain the contents for one building (or other
logical division of your universe). The reason for this is that the definitions
in the file are intentionally not keyed by a globally unique identifier. This is
done for a few of reasons:

1.  The human-readable entity name is, well, more human readable.
2.  Using human-readable names, which are typically created at design time and
    known a-priori, allows for incremental population of the file at different
    stages of the commissioning or onboarding process, rather than having to
    wait until all the devices are cloud-registered.
3.  There is inherent value to forcing locally unique naming of spaces and
    equipment (because it makes it easier to find stuff).

It would be trivial to flip the ID to be the top-level key and replace it with a
"name" attribute for global uniqueness of top level keys.

### Config Format

The configuration format is focused around defining the entities in the model. A
generic entity with all possible top level fields looks like this[^5]:

```
ENTITY-NAME:
  type: NAMESPACE/A_DIGITAL_BUILDINGS_ENTITY_TYPE
  id: SYSTEM/ID1234
  connections:
    # Listed entities are sources on connections
    ANOTHER-ENTITY: FEEDS
    A-THIRD-ENTITY: CONTAINS
  links:
    A-FOURTH-ENTITY:
      # source_device_field: this_device_field
      supply_air_damper_position_command_1: supply_air_damper_command
      zone_air_temperature_1: zone_air_temperature_sensor
  translation:
    zone_air_temperature_sensor:
      present_value: "points.temp_1.present_value"
      units:
        key: "pointset.points.temp_1.units"
        values:
          degrees_celsius: "degC"
          degrees_fahrenheit: "degF"
    supply_air_isolation_damper_command:
      present_value: "points.damper_1.present_value"
      states:
        OPEN: "1"
        CLOSED: "2"
```

*   **Entity Name:** The human readable identifier for the entity. This should
    be unique in document scope.
*   **Type:** A valid, fully qualified Digital Buildings entity type that
    represents this entity
*   **Id:** A globally unique identifier for this entity.
*   **Connections:** Used to specify connections from other entities (sources)
    pointing to this entity, with connection types. Entities are keys and cannot
    be repeated. Values are one or more connections, specified as a single
    value or a set.
*   **Links:** Used to specify mappings between standard fields of source
    entities to standard fields of this entity. First level key is another
    entity in the file (source). Second level key is a source standard field
    followed by a `:` and a standard field of this entity.
*   **Translation:** Used to specify how the fields of the devices native
    payload map to the standard fields of this entity's type. See
    [translation section](#translations) for more detail.

### Spaces

In nearly every model, entities should exist for Buildings, Floors, and Rooms.
The following example shows a building with one floor and one room:

```
# Building
UK-LON-S2:
  type: FACILITIES/BUILDING
  id: FACILITIES/123456

# Floor
UK-LON-S2-1:
  type: FACILITIES/FLOOR
  id: FACILITIES/3456789
  connections:
    UK-LON-S2: CONTAINS

# Room
UK-LON-S2-1-1C3G:
  type: FACILITIES/ROOM
  id: FACILITIES/2345678
  connections:
    UK-LON-S2-2: CONTAINS

```

*   Buildings shall have `CONTAINS` connections to Floors
*   Floors should have `CONTAINS` connections to all Rooms
*   Floors should have `CONTAINS` connections to all Devices

In this example, entities are named using their standardized \[up to\]5-segment
codes. Codes of this type are widely used and highly recommended due to their
global-uniqueness and embedded hierarchy.

Types for spaces are contained in the `FACILITIES` namespace of the ontology.

### Devices

#### Reporting Physical Devices

When sending data from a building via Cloud IoT, a reporting device is any
device with its own entry in Cloud Device Manager (CDM)[^1].

For clarity the human readable ID of the device in CDM and the entity name in
the config file should be the same[^6]. If the building also has a CAD drawing
or BIM model, good practice is for this name to also exist in the CAD or BIM
model.

The ID of the device should be a globally unique and persistent identifier for
the entity in your system. In the case of devices sending data via Cloud IoT we
use the CDM `numId` prefixed with `CDM/` as a namespace.

Choose an entity type that has the correct fields for this type.

Define a translation as necessary...

##### Defining Translations

It is commonly (always?) the case that real devices have data payloads that
differ from our modeled entity types. In this case, it is necessary to define a
translation between the native payload and the standard form. This
standardization includes the _field names_, _field values_, _dimensional units_
and _multistate definitions_.

Below is a minimal example of what a translation configuration looks like in
long form:

```
FCU-123:
  ...
  translation:
    zone_air_temperature_sensor:
      present_value: "points.temp_1.present_value"
      units:
        key: "pointset.points.temp_1.units"
        values:
          degrees_celsius: "degC"
          degrees_fahrenheit: "degF"
    supply_air_isolation_damper_command:
      present_value: "points.damper_1.present_value"
      states:
        OPEN: "1"
        CLOSED: "2"
```

Inside the `translation` block, keys correspond to standard fields in the
ontology. Within each field block we provide information about the following:

*   `present_value`: defines the fully qualified path in the devices native JSON
    payload that contains the value of this field
*   `units`: when `present_value` is a dimensional number, this block defines
    information about the payload location that defines dimensional units for
    this field's `present_value`
    *   `key`: defines the fully qualified path to the section of the payload
        that calls out the units
    *   `values`: Maps standard Digital Buildings units to the values in the
        payload that represent those units
*   `states`: If `present_value` represents a multistate value, this block is
    used to map the native state values to standard ones. Standard values are
    the map keys.

###### Translation Shortcuts

In order to eliminate duplicate work, the format provides some shortcuts to
translation definitions:

1.  Substitute the `translation` block with `translate_like:ENTITY-NAME` to use
    a translation that is already defined on another entity.
2.  For devices that comply with
    [UDMI](https://github.com/faucetsdn/udmi)
    a short form can be used.

###### UDMI Short form

Because UDMI strictly defines the path to points and units in the payload, as
well as name correspondence between `units` and `present_value` much of the
information in the translation definition can be omitted (The parser assumes
UDMI compliant payloads are the default).

```
FCU-123:
  ...
  translation:
    zone_air_temperature_sensor:
      present_value: "temp_1"
      unit_values:
        degrees_celsius: "degC"
        degrees_fahrenheit: "degF"
    supply_air_isolation_damper_command:
      present_value: "damper_1"
      states:
        OPEN: "1"
        CLOSED: "2"
```

The more compliant data the device has, the smaller the translation can be. The
same device with Digital Building ontology standard state and unit values looks
like:

```
FCU-123:
  ...
  translation:
    zone_air_temperature_sensor: "temp_1"
    supply_air_isolation_damper_command: "damper_1"
```

A device that is UDMI compliant and uses standard values from the ontology can
simply specify:

```
FCU-123:
  ...
  translation: COMPLIANT
```

##### Metadata

Often it is useful to include metadata about devices in our model (and the
provided abstract model includes metadata points in its types).  To do this in
the building config, one can add a `metadata` block on an entity description:

```
FCU-123:
  ...
  metadata:
    discharge_air_flowrate_capacity:
      present_value:"300"
      units: "cubic_feet_per_minute"
    manufacturer_label: "Carrier"
```

For entries with dimensional units, `present_value` and `units` subentries must
be specified.  For strings or point types with implied units, the value may be
inlined.  Because metadata is user-specified, it is required that fields and
unit names all be in standard form.

#### Virtual Devices

In many cases the logical device and the reporting device are the same thing
(i.e. the device that sends data is also the entity type you want in your
model). When the two are different (i.e. the logical device does not send its
own data) a virtual device is required.

Virtual entities are nearly always logical entities. Because logical entities
are the representations that the applications using your model will care about,
virtual devices should generally map to canonical types. In an integrated design
in construction stack, logical devices should be called out by name in the
CAD/BIM models and the same name should be used for them in this config.

A virtual entity example:

```
VAV-32:
  type: NAMESPACE/DEVICE_TYPE
  id: SOME_GUID_12345  # optional
  links:
    ANOTHER-ENTITY:
      # source_device_field: this_device_field
      supply_air_damper_position_command_1: supply_air_damper_command
      ...
```

The `name` and `type` fields are similar to reporting devices, however because a
logical device may not exist until this file is consumed it may be impossible to
assign an `id` field. This will depend on your application.

The key difference between virtual and reporting entities is that all the fields
of a virtual entity are derived via `links`. the link block lists all the source
entities and fields that contribute to this entity's data and provides a mapping
to this entity's local fields.

#### Device Relationships

In addition to telemetry points many devices will have relationships to other
entities. System and spatial relationships are defined with the `connections`
block. Connection definitions work the same way for all entities, with
connections always defined on the target of the connection.

Expanding the VAV definition from the previous section, and adding some lights:

```
VAV-32:
  type: HVAC/VAV
  connections:
    UK-LON-6PS-1: CONTAINS
    AHU-123: FEEDS

LF-123:
  type: LIGHTING/LIGHTING_FIXTURE
  connections:
    UK-LON-6PS-1-1A2: CONTAINS
    LCG-234: HAS_PART
```

### Zones and Control Groups

In addition to spaces and devices, most buildings have other types of Logically
defined areas or groups that aren't strictly a "device". These entities are
simply virtual devices, following all the same rules, but often do not have
`links`.

Here are some examples:

```
# HVAC Zone
ZONE-123:
  type: HVAC/ZONE
  connections:
    UK-LON-6PS-1:CONTAINS
    VAV-123: FEEDS

# Lighting Control Group
LCG-234:
  type: LIGHTING/SWITCH_GROUP
  connections:
    UK-LON-6PS-1: CONTAINS
    SW-456: CONTROLS
```

### Relationships

System and spatial relationships are defined with the `connections` block.
Connection definitions work the same way for all entities, with connections
always defined on the target of the connection. Here's an example

## Validation
The building config can be machine validated for consistency and adherence to
the rules defined in the data model. This tool is available [here][https://github.com/google/digitalbuildings/tree/master/tools/validators/instance_validator].

<!-- Footnotes themselves at the bottom. -->

## Notes

[^1]: Practically speaking, the entry typically corresponds to the controller,
    which may or may not map to exactly one complete piece of equipment. \
[^2]:
     It is anticipated that non 1:1 mapping will only apply to HVAC equipment. \
[^3]:
     A fully compliant UDMI payload uses standard names for units, formatted
     with points in the payload using the fully qualified path
     `points.<name>.present_value` and units in metadata with the path `
     pointset.points.<name>.units`.  A UDMI compliant field will use the exact
     text (case insensitive) for multi-states, and all states defined for the
     field will be used. \
[^5]: A user would almost never define all the sections in a single entity, but
    all are shown below for illustration purposes. \
[^6]: An unstated assumption here is that the CDM registry scope and the scope
    of the config file are the same. This guarantees that a unique ID can
    be found in the CDM registry for each entity.
